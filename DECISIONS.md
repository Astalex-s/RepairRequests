# DECISIONS

Ключевые архитектурные решения проекта и их обоснование.

---

## 1. Repository + Service слои (роутеры без SQL)

**Решение:** Роутеры содержат только HTTP-логику; SQL и работа с БД изолированы в repositories; бизнес-правила — в services.

**Обоснование:** Разделение ответственности упрощает тестирование и замену слоёв. Роутер вызывает service, service — repository. Изменение схемы БД не затрагивает роутеры.

**Компромисс:** Больше файлов и переходов между слоями; для простых CRUD это может казаться избыточным.

---

## 2. Async SQLAlchemy + Postgres (логика БД в repositories)

**Решение:** Используем async SQLAlchemy с asyncpg; вся логика запросов, фильтров и маппинга сосредоточена в repositories.

**Обоснование:** Async даёт лучшую масштабируемость при I/O-bound нагрузке. Postgres — надёжная ACID-БД с поддержкой конкурентного доступа. Хранение SQL в одном месте упрощает рефакторинг и миграции.

**Компромисс:** Async-код сложнее отлаживать; требуется понимание event loop.

---

## 3. Миграции Alembic в entrypoint, сиды — отдельный шаг

**Решение:** При старте контейнера backend выполняется `alembic upgrade head`; сиды (`python -m app.seed`) вызываются отдельно в том же entrypoint, но логически — отдельный скрипт.

**Обоснование:** Миграции в entrypoint гарантируют актуальную схему при каждом деплое. Сиды — тестовые данные, их отделение от DDL позволяет не смешивать структуру и данные, а также запускать сиды выборочно (только dev).

**Компромисс:** При падении миграций контейнер не стартует; нужен мониторинг и откат миграций вручную при ошибках.

---

## 4. «Взять в работу» — один условный UPDATE, 409 при гонке

**Решение:** Операция «взять заявку в работу» реализована одним `UPDATE ... WHERE status='new' AND master_id IS NULL`; второй конкурентный запрос получает 409 («Заявка уже взята в работу»).

**Обоснование:** Условный UPDATE атомарен на уровне Postgres — один запрос выигрывает, второй не обновляет строки. Нет необходимости в SELECT FOR UPDATE и явных блокировках. 409 — стандартный код для конфликта при конкурентном доступе.

**Компромисс:** Клиент должен обрабатывать 409 и предлагать обновить список; нет детализации «кто взял».

---

## 5. JWT Bearer для внутренних ролей, публичный endpoint только для создания заявок

**Решение:** Эндпоинты диспетчера и мастера защищены JWT Bearer; POST /requests (создание заявки) — публичный, без токена.

**Обоснование:** Клиент может создать заявку без регистрации — снижает трение. Внутренние роли (dispatcher, master) требуют входа; JWT — stateless, подходит для нескольких инстансов. Сообщения об ошибках аутентификации унифицированы («Неверный логин или пароль») для безопасности.

**Компромисс:** Публичное создание — риск спама; при необходимости потребуется rate limiting или капча.

---

## 6. Frontend: plain CSS, без тяжёлых UI-библиотек, лаконичный стиль

**Решение:** UI реализован на React с собственными CSS-переменными (design tokens); без Tailwind, MUI, Ant и т.п. Стиль — минималистичный: много whitespace, типографика, простые компоненты.

**Обоснование:** Меньше зависимостей и размера бандла; полный контроль над стилями. Лаконичный интерфейс быстрее загружается и не отвлекает от задач. Design tokens упрощают поддержку и возможное добавление тем.

**Компромисс:** Сложные UI-паттерны (модалки, автокомплит, датапикеры) придётся реализовывать вручную или подключать точечно.
